reduce() применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.

let items = [
  {a: "test1", b: 200},
  {a: "test2", b: 50},
  {a: "test3", b: 700}
];

let max = (items.reduce((calc, current) => calc.b < current.b ? calc : current)).b;
console.log(max);

Колво элементов true в массиве обьектов:

let max = array.reduce((calc, current) => current.bool == true ? calc + 1 : calc + 0, 0);
или
let max = (calc, current) => current.inStore ? calc + 1 : calc, 0)

--------------------------------------------------------------------
map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.

--------------------------------------------------------------------

find() возвращает значение первого найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции. В противном случае возвращается undefined.

const findItem = items.find(current => current.b == 200);

--------------------------------------------------------------------

Чет нечет:

10 % 2 == 0
true

21 % 2 == 0
true

--------------------------------------------------------------------
Редирект реакт:

import {useNavigate, useParams} from "react-router-dom";

const navigate = useNavigate();

navigate(`/admin/news/`);

--------------------------------------------------------------------
Сумма разных элементов массива обьектов:

const sumPrice = cartList.cart.map(item => item.price * item.qnt).reduce((prev, curr) => prev + curr, 0);

--------------------------------------------------------------------

Поиск в массиве js

let available = array.find(elem => elem.idGood == idGood);

array.find(elem => elem.idGood == coll[i]);

--------------------------------------------------------------------
Сортировка массива:

const bubbleSort = (coll) => {
  let stepsCount = coll.length - 1;
  let swapped;
  do {
    swapped = false;
    for (let i = 0; i < stepsCount; i += 1) {
      if (coll[i] > coll[i + 1]) {
        const temp = coll[i];
        coll[i] = coll[i + 1];
        coll[i + 1] = temp;
        swapped = true;
      }
    }
    stepsCount -= 1;
  } while (swapped); // продолжаем, пока swapped === true
  return coll;
};

console.log(bubbleSort([3, 2, 10, -2, 0]));

    const storeSort = (cartList: any, storeItem: any) => {
        let stepsCount = cartList.length - 1;
        let swapped;
        do {
            swapped = false;
            for (let i = 0; i < stepsCount; i += 1) {
                if (!storeItem.cart.find((elem: { idGood: any; }) => elem.idGood == cartList[i].idGood)) {
                    const temp = cartList[i];
                    cartList[i] = cartList[i + 1];
                    cartList[i + 1] = temp;
                    swapped = true;
                }
            }
            stepsCount -= 1;
        } while (swapped);
        return cartList;
    };

    storeSort(cartList, storeItem);

--------------------------------------------------------------------
Функциональынй компонент реакт:

export interface SearchFilterProps {
    name: string;
    setName: Dispatch<SetStateAction<string>>;
    label: string;
}

const SearchItem = ({name, setName, label}: SearchFilterProps) => {
    return (
        <>
        </>
    );
};

--------------------------------------------------------------------
Ширина блоков:
 <Grid container spacing={2}>
  <Grid item xs={4} /*sm={12} md={12} lg={3}*/>
  </Grid>
</Grid>

--------------------------------------------------------------------
Условный рендеринг:

{ count && <h1>Количество сообщений: {count}</h1>}

<b>{isLoggedIn ? 'сейчас' : 'не'}</b>

--------------------------------------------------------------------
Sticky блок:

npm install react-sticky

<StickyContainer style={{ height: "5000px", outline: "1px solid" }}>
  <Sticky>{({ style }) => <div style={style}>Sticky thing!</div>}</Sticky>
</StickyContainer>

--------------------------------------------------------------------

sx={{ display: { xs: 'none', md: 'block' }

--------------------------------------------------------------------
Превью изображения в инпуте реакт:

    const [selectedImg, setSelectedImg] = useState<string>('');
    
       <Input
                            inputProps={{
                                accept: "application/jpeg, application/jpg, application/pdf, image/*",
                            }}
                            sx={{display: 'none'}}
                            type="file"
                            name="img"
                            id="img-loader-button"
                            key={Date.now()}
                            onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                                if (event.currentTarget.files) {
                                    setValue('img', event.currentTarget.files[0]);
                                    const objectUrl = URL.createObjectURL(event.currentTarget.files[0]);
                                    setSelectedImg(objectUrl);
                                }
                            }}
                        />


                             {
                            selectedImg && <CardMedia
                                sx={{height: '200px', width: '300px', backgroundSize: 'cover'}}
                                style={{backgroundImage: `url(${selectedImg})`}}>
                            </CardMedia>
                        }


--------------------------------------------------------------------
Передача параметров в гет запросе react toolKit:

fetchBrandList: build.query<ResponseGeneric<BrandItemInterface[]>, any>({
    query: (arg) => ({
        url: 'brand',
        method: 'GET',
        params: arg
    }),
}),

--------------------------------------------------------------------
Адаптивные блоки реакт:

<Grid key={item.id} item xs={12} sm={6} md={!openSidebar ? 3 : 4} lg={3}>
    <NewsCard item={item}/>
</Grid>

--------------------------------------------------------------------
функциональный компонент с дженериком:
(с расширением свойств для дженерика)

interface IControllerInterface<T> {
    items?: T[];
    name: string;
}

export default function ControllerSelect<T extends { id?: number, name: string }>
({items, name, label}: IControllerInterface<T>): JSX.Element {
    return (
        <></>
    )
}

<ControllerSelect<TagItemInterface> items={tags} name={'idTag'} label={'Тип'}/>