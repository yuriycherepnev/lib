Согласно спецификации «в Go область видимости ограничена блоками».
В основном это значит, что переменные существуют только внутри текущих фигурных скобок { } (в блоке), включая все вложенные скобки (блоки). 

------------------------------------------------------------

func Intn(n int) int

Intn возвращает в виде int неотрицательное псевдослучайное число в полуоткрытом интервале [0,n) (больше 0, но меньше n)

------------------------------------------------------------

В Go только один оператор равенства, через который нельзя сравнивать текст и число. Тем не менее, можно конвертировать число в текст и наоборот.

------------------------------------------------------------

Go использует логику короткого замыкания.
Если первое условие истинно, тогда нет нужды проверять условие, что следует за оператором ||, поэтому оно будет игнорироваться.

------------------------------------------------------------

Оператор fallthrough используется в предложении case switch. Он должен использоваться в конце предложения case.
Он используется для выполнения следующего предложения case без проверки выражения.

------------------------------------------------------------

range

цикл range предоставляет как index (или ключ в map), так и текущее value.

------------------------------------------------------------

:= - обьявление и присваивание
= только присваивание

Вы не можете использовать := вне funcs. Это потому, что вне функции оператор должен начинаться с ключевого слова.
Всеоператоры вне функции должны начинаться с ключевого слова

:= можно использовать для многопеременных объявлений и назначений

foo, bar := 42, 314

------------------------------------------------------------

Функция main() должна появляться в коде только один раз, находиться в пакете main(), и не получать и не возвращать никаких аргументов.

Полная программа создается путем транзитивного связывания одного неимпортированного пакета, 
называемого основным пакетом , со всеми пакетами, которые он импортирует. 
Основной пакет должен иметь имя пакета main и объявлять функцию main, 
которая не принимает аргументов и не возвращает значения.

Выполнение программы начинается с инициализации программы и последующего вызова функции mainв package main. 
Когда вызов этой функции возвращается, программа завершается. Она не ждет main завершения других горутин.

------------------------------------------------------------
для преобразования типа можно использовать имя типа в качестве функции.

float64(x)

------------------------------------------------------------
массив - структура данных с фиксированной длинной

x := [5]float64{98, 93, 77, 82, 83}

срез - структура данных с нефиксированной длинной

Срезы (slice) представляют последовательность элементов одного типа переменной длины. 
В отличие от массивов длина в срезах не фиксирована и динамически может меняться, 
то есть можно добавлять новые элементы или удалять уже существующие.

Срез создается встроенной функцией make:
x := make([]float64, 5)

append создает новый срез из уже существующего (первый аргумент) и добавляет к нему все следующие аргументы.

map (также известна как ассоциативный массив или словарь) — это неупорядоченная коллекция пар вида ключ-значение. 

очень частый способ использования карт — в качестве словаря или таблицы. 

make([]int, 3, 9)
здесь длина среза 3, длина массива на который указывает срез 9

------------------------------------------------------------

Go использует неявный оператор break для каждого случая.

------------------------------------------------------------

Сигнатура функции - совокупность аргументов и возвращаемых значений

Тело фукнции - код заключенный в фигурных скобках

panic - вызывает ошибку выполнения

функции не имеют доступа к области видимости родительской функции

функции выстраиваются в «стек вызовов».

При создании локальная функция также получает доступ к локальным переменным

Функцию, использующую переменные, определенные вне этой функции, называют замыканием.

defer позволяет отложить вызов указанной функции до тех пор, пока не завершится текущая. 
Грубо говоря defer перемещает вызов функции в конец текущей
отложенные функции вызываются, даже если во время выполнения происходит ошибка.
Например:
f, _ := os.Open(filename)
defer f.Close()

------------------------------------------------------------

Panic - генерация ошибки 
recover - останавливает панику и возвращает значение, которое было передано функции panic.
Recover следует использова в связке с defer

------------------------------------------------------------

Горутины — это функции или методы, выполняемые конкурентно с другими горутинами в одном и том же адресном пространстве. 
Они легковеснее традиционных потоков, занимают меньше памяти и позволяют эффективно использовать ядра процессора.

sync.WaitGroup - простой способ дождаться выполнения всех горутин

При коммуникации горутин нет необходимости использовать WaitGroup так как мы ожидаем выполнения всех горутин при помощи механизма чтения из канала.

------------------------------------------------------------

Указатели указывают на участок в памяти, где хранится значение.
(передача по ссылке из php)

оператор &, который используется для получения адреса переменной. 

new принимает аргументом тип, выделяет для него память и возвращает указатель на эту память.

------------------------------------------------------------

Краткое объявление недоступно для переменных, объявленных в области видимости пакета

------------------------------------------------------------

Тип - описание будущей структуры
(аналог класса из пхп)

Структура — это тип, содержащий именованные поля. 
(посути аналог обьекта пхп)
По умолчанию аргументы в Go всегда копируются. 

Функция с получателем - аналог метода обьекта из пхп. Подвязывает метод к структуре, и в дальнейшем мы
можем обратиться к этому методу из структуры.

Встраиваемые типы - один тип вложенный в другой (структура в структуре)

Интерфейс - описывает какие методы реализуются в структуре
Множество методов - это список методов, которые будут использоваться для «реализации» интерфейса.

------------------------------------------------------------
При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной типа float32/float64:
