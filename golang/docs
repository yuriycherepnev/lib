Согласно спецификации «в Go область видимости ограничена блоками».
В основном это значит, что переменные существуют только внутри текущих фигурных скобок { } (в блоке), включая все вложенные скобки (блоки). 

------------------------------------------------------------

В Go существуют следующие типы целых чисел: uint8, uint16, uint32, uint64, int8, int16, int32 и int64. 8, 16, 32 и 64 говорит нам, сколько бит использует каждый тип. uint означает «unsigned integer» (беззнаковое целое), в то время как int означает «signed integer» (знаковое целое). Беззнаковое целое может принимать только положительные значения (или ноль). В дополнение к этому существуют два типа-псевдонима: byte (то же самое, что uint8) и rune (то же самое, что int32). Байты — очень распространенная единица измерения в компьютерах (1 байт = 8 бит, 1024 байта = 1 килобайт, 1024 килобайта = 1 мегабайт, …), и именно поэтому тип byte в Go часто используется для определения других типов. Также существует 3 машинно-зависимых целочисленных типа: uint, int и uintptr. Они машинно-зависимы, потому что их размер зависит от архитектуры используемого компьютера.

В общем, если вы работаете с целыми числами — просто используйте тип int.

------------------------------------------------------------

Массив — это нумерованная последовательность элементов одного типа с фиксированной длиной.
var x [5]int
[0 0 0 0 0]
x := [5]float64{ 98, 93, 77, 82, 83 }

Срез - это часть массива. Как и массивы, срезы индексируются и имеют длину. В отличии от массивов их длину можно изменить. 
var x []float64
x := make([]float64, 5)

Короткая запись:
arr := [5]float64{1,2,3,4,5}
x := arr[0:5]

slice1 := []int{1,2,3}
slice2 := append(slice1, 4, 5)

slice1 := []int{1,2,3}
slice2 := make([]int, 2)
copy(slice2, slice1)
скопируются только 2 элемента массива

Карта (также известна как ассоциативный массив или словарь) — это неупорядоченная коллекция пар вида ключ-значение.
var x map[string]int

x := make(map[string]int)
x["key"] = 10

elements := map[string]string{
    "H": "Hydrogen",
    "He": "Helium",
}

------------------------------------------------------------

func Intn(n int) int

Intn возвращает в виде int неотрицательное псевдослучайное число в полуоткрытом интервале [0,n) (больше 0, но меньше n)

------------------------------------------------------------

В Go только один оператор равенства, через который нельзя сравнивать текст и число. Тем не менее, можно конвертировать число в текст и наоборот.

------------------------------------------------------------

Go использует логику короткого замыкания.
Если первое условие истинно, тогда нет нужды проверять условие, что следует за оператором ||, поэтому оно будет игнорироваться.

------------------------------------------------------------

Оператор fallthrough используется в предложении case switch. Он должен использоваться в конце предложения case.
Он используется для выполнения следующего предложения case без проверки выражения.

------------------------------------------------------------

range

цикл range предоставляет как index (или ключ в map), так и текущее value.

------------------------------------------------------------

:= - обьявление и присваивание
= только присваивание

Вы не можете использовать := вне funcs. Это потому, что вне функции оператор должен начинаться с ключевого слова.
Всеоператоры вне функции должны начинаться с ключевого слова

:= можно использовать для многопеременных объявлений и назначений

foo, bar := 42, 314

------------------------------------------------------------

Функция main() должна появляться в коде только один раз, находиться в пакете main(), и не получать и не возвращать никаких аргументов.

Полная программа создается путем транзитивного связывания одного неимпортированного пакета, 
называемого основным пакетом , со всеми пакетами, которые он импортирует. 
Основной пакет должен иметь имя пакета main и объявлять функцию main, 
которая не принимает аргументов и не возвращает значения.

Выполнение программы начинается с инициализации программы и последующего вызова функции mainв package main. 
Когда вызов этой функции возвращается, программа завершается. Она не ждет main завершения других горутин.

------------------------------------------------------------
для преобразования типа можно использовать имя типа в качестве функции.

float64(x)

------------------------------------------------------------
массив - структура данных с фиксированной длинной

x := [5]float64{98, 93, 77, 82, 83}

срез - структура данных с нефиксированной длинной

Срезы (slice) представляют последовательность элементов одного типа переменной длины. 
В отличие от массивов длина в срезах не фиксирована и динамически может меняться, 
то есть можно добавлять новые элементы или удалять уже существующие.

Срез создается встроенной функцией make:
x := make([]float64, 5)

append создает новый срез из уже существующего (первый аргумент) и добавляет к нему все следующие аргументы.

map (также известна как ассоциативный массив или словарь) — это неупорядоченная коллекция пар вида ключ-значение. 

очень частый способ использования карт — в качестве словаря или таблицы. 

make([]int, 3, 9)
здесь длина среза 3, длина массива на который указывает срез 9

------------------------------------------------------------

Go использует неявный оператор break для каждого случая.

------------------------------------------------------------

Сигнатура функции - совокупность аргументов и возвращаемых значений

Тело фукнции - код заключенный в фигурных скобках

panic - вызывает ошибку выполнения

функции не имеют доступа к области видимости родительской функции

функции выстраиваются в «стек вызовов».

При создании локальная функция также получает доступ к локальным переменным

Функцию, использующую переменные, определенные вне этой функции, называют замыканием.

defer позволяет отложить вызов указанной функции до тех пор, пока не завершится текущая. 
Грубо говоря defer перемещает вызов функции в конец текущей
отложенные функции вызываются, даже если во время выполнения происходит ошибка.
Например:
f, _ := os.Open(filename)
defer f.Close()

------------------------------------------------------------

Panic - генерация ошибки 
recover - останавливает панику и возвращает значение, которое было передано функции panic.
Recover следует использова в связке с defer

------------------------------------------------------------

Горутины — это функции или методы, выполняемые конкурентно с другими горутинами в одном и том же адресном пространстве. 
Они легковеснее традиционных потоков, занимают меньше памяти и позволяют эффективно использовать ядра процессора.

sync.WaitGroup - простой способ дождаться выполнения всех горутин

При коммуникации горутин нет необходимости использовать WaitGroup так как мы ожидаем выполнения всех горутин при помощи механизма чтения из канала.

------------------------------------------------------------

Указатели указывают на участок в памяти, где хранится значение.
(передача по ссылке из php)

оператор &, который используется для получения адреса переменной. 

new принимает аргументом тип, выделяет для него память и возвращает указатель на эту память.

------------------------------------------------------------

Краткое объявление недоступно для переменных, объявленных в области видимости пакета

------------------------------------------------------------

Тип - описание будущей структуры
(аналог класса из пхп)

Структура — это тип, содержащий именованные поля. 
(посути аналог обьекта пхп)
По умолчанию аргументы в Go всегда копируются. 

Функция с получателем - аналог метода обьекта из пхп. Подвязывает метод к структуре, и в дальнейшем мы
можем обратиться к этому методу из структуры.

Встраиваемые типы - один тип вложенный в другой (структура в структуре)

Интерфейс - описывает какие методы реализуются в структуре
Множество методов - это список методов, которые будут использоваться для «реализации» интерфейса.

------------------------------------------------------------
При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной типа float32/float64:
