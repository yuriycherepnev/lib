Согласно спецификации «в Go область видимости ограничена блоками».
В основном это значит, что переменные существуют только внутри текущих фигурных скобок { } (в блоке), включая все вложенные скобки (блоки). 

------------------------------------------------------------

В Go существуют следующие типы целых чисел: uint8, uint16, uint32, uint64, int8, int16, int32 и int64. 8, 16, 32 и 64 говорит нам, сколько бит использует каждый тип. uint означает «unsigned integer» (беззнаковое целое), в то время как int означает «signed integer» (знаковое целое). Беззнаковое целое может принимать только положительные значения (или ноль). В дополнение к этому существуют два типа-псевдонима: byte (то же самое, что uint8) и rune (то же самое, что int32). Байты — очень распространенная единица измерения в компьютерах (1 байт = 8 бит, 1024 байта = 1 килобайт, 1024 килобайта = 1 мегабайт, …), и именно поэтому тип byte в Go часто используется для определения других типов. Также существует 3 машинно-зависимых целочисленных типа: uint, int и uintptr. Они машинно-зависимы, потому что их размер зависит от архитектуры используемого компьютера.

В общем, если вы работаете с целыми числами — просто используйте тип int.

------------------------------------------------------------

Мьютекс (или взаимная блокировка) единовременно блокирует часть кода в одном потоке, а так же используется для защиты общих ресурсов из не-атомарных операций. 

------------------------------------------------------------

Массив — это нумерованная последовательность элементов одного типа с фиксированной длиной.
var x [5]int
[0 0 0 0 0]
x := [5]float64{ 98, 93, 77, 82, 83 }

Срез - это часть массива. Как и массивы, срезы индексируются и имеют длину. В отличии от массивов их длину можно изменить. 

в отличии от массива срез нужно инициализировать без указания размера
a := []int{1, 2, 3}

также срез можно создать на основе существующего массива
m := [3]string{"Шито", "Крыто", "Корыто"}
b := m[0:2]
fmt.Printf("%#v\n", b) 

во время инициализации среза сначала инициализируется массив,
там сохраняются переданные значения и сразу создаётся срез,
указывающий на этот массив и хранящий длину и емкость

Срез - это ссылка на исходный массив, значит, чтобы существовать этому срезу, и массив должен существовать.
Поэтому, если мы определили массив (или срез) из большого количества элементов, взяли небольшой 
новый срез от него и дальше используем только значения нового среза, 
значит большое количество элементов из исходного массива (среза) 
будут жить в памяти, несмотря на то, что они нам больше не нужны.

срез - это просто ссылка на массив, и каждый элемент среза - это ссылки на элементы связанного массива. 
По этой причине нужно быть аккуратным, когда мы в функцию передаем срез. 
В Go всё можно передать по значению, и срез не исключение, 
но значением среза является ссылка, поэтому при такой 
передаче функция будет менять значения исходного массива

!!!значением среза является ссылка на исходный массив!!!

var x []float64
x := make([]float64, 5)

Короткая запись:
arr := [5]float64{1,2,3,4,5}
x := arr[0:5]

slice1 := []int{1,2,3}
slice2 := append(slice1, 4, 5)

slice1 := []int{1,2,3}
slice2 := make([]int, 2)
copy(slice2, slice1)
скопируются только 2 элемента массива

Карта (также известна как ассоциативный массив или словарь) — это неупорядоченная коллекция пар вида ключ-значение.
var x map[string]int

x := make(map[string]int)
x["key"] = 10

elements := map[string]string{
    "H": "Hydrogen",
    "He": "Helium",
}

------------------------------------------------------------

Функции 

В совокупности аргументы и возвращаемое значение также известны как сигнатура функции.

func main() {
    fmt.Println(f1())
}
func f1() int {
    return f2()
}
func f2() int {
    return 1
}

Каждая вызываемая функция помещается в стек вызовов, каждый возврат из функции возвращает нас к предыдущей приостановленной подпрограмме;

Функцию, использующую переменные, определенные вне этой функции, называют замыканием.

func main() {
    x := 0
    increment := func() int {
        x++
        return x
    }
    fmt.Println(increment())
    fmt.Println(increment())    
}

Замыкание и рекурсивный вызов — сильные техники программирования, формирующие основу парадигмы, известной как функциональное программирование. Большинство людей находят функциональное программирование более сложным для понимания, чем подход на основе циклов, логических операторов, переменных и простых функций.

------------------------------------------------------------
Указатели.

в Go всё передаётся "по значению", тоесть буквально копируется.

При передаче в функцию параметра по значению - копируется сама переменная, при передаче по ссылке - копируется ссылка.

Когда мы вызываем функцию с аргументами, аргументы копируются в функцию.

Указатели представляют собой объекты, значением которых служат адреса других объектов (например, переменных).

Указатель определяется как обычная переменная, только перед типом данных ставится символ звездочки *. Например, определение указателя на объект типа int:
    
var p *int

Для получения адреса применяется операция &, после которой указывается имя переменной (&x).

package main
 
import "fmt"
 
func main() {
     
    var x int = 4       // определяем переменную
    var p *int          // определяем указатель 
    p = &x              // указатель получает адрес переменной
    fmt.Println(p)      // значение самого указателя - адрес переменной x
}

Разыменовать указатель - это найти данные из блока памяти, на который указывает адрес в блоке памяти указателя

Адрес в памяти обычно указывается в шестнадцатеричной форме (напр. 1A45F0D)

Разыменование указателя - передача переменной по ссылке:

package main
 
import "fmt"
 
func main() {
     
    var x int = 4
    var p *int  = &x                // указатель получает адрес переменной
    fmt.Println("Address:", p)      // значение указателя - адрес переменной x
    fmt.Println("Value:", *p)       // значение переменной x
}

И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:

var x int = 4
var p *int = &x
*p = 25
fmt.Println(x)      // 25

Для определения указателей можно использовать также сокращенную форму:

f := 2.3
pf := &f
     
fmt.Println("Address:", pf)
fmt.Println("Value:", *pf)

Если указателю не присвоен адрес какого-либо объекта, то такой указатель по умолчанию имеет значение nil.

Переменная представляет именованный объект в памяти. Язык Go также позволяет создавать безымянные объекты - они также размещаются в памяти, но не имеют имени как переменные. Для этого применяется функция new(type). В эту функцию передается тип, объект которого надо создать. Функция возвращает указатель на созданный объект:

package main
 
import "fmt"
 
func main() {
     
    p := new(int) 
    fmt.Println("Value:", *p)       // Value: 0 - значение по умолчанию
    *p = 8                          // изменяем значение
    fmt.Println("Value:", *p)       // Value: 8
}

Объект, созданный с помощью функции new, ничем не отличается от обычной переменной. Единственное что, чтобы обратиться к этому объекту - получить или изменить его адрес, необходимо использовать указатель.


func zero(xPtr *int) {
    *xPtr = 0
}
func main() {
    x := 5
    zero(&x)
    fmt.Println(x) // x is 0
}

В Go указатели представлены через оператор * (звёздочка), за которым следует тип хранимого значения. В функции zero xPtr является указателем на int.

* также используется для «разыменовывания» указателей. Когда мы пишем *xPtr = 0, то читаем это так: «Храним int 0 в памяти, на которую указывает xPtr». Если вместо этого мы попробуем написать xPtr = 0, то получим ошибку компиляции, потому что xPtr имеет тип не int, а *int. Соответственно, ему может быть присвоен только другой *int.

Также существует оператор &, который используется для получения адреса переменной. &x вернет *int (указатель на int) потому что x имеет тип int. Теперь мы можем изменять оригинальную переменную. &x в функции main и xPtr в функции zero указывают на один и тот же участок в памяти.

Другой способ получить указатель — использовать встроенную функцию new:

func one(xPtr *int) {
    *xPtr = 1
}
func main() {
    xPtr := new(int)
    one(xPtr)
    fmt.Println(*xPtr) // x is 1
}

Функция new принимает аргументом тип, выделяет для него память и возвращает указатель на эту память.

В некоторых языках программирования есть существенная разница между использованием new и &, и в них нужно удалять всё, что было создано с помощью new. Go — язык с автоматической сборкой мусора. Это означает, что область памяти очищается автоматически, когда на неё не остаётся ссылок.

Итого:
* - используется для обьявления указателя, разыменования указателя и присвоения нового значения для указателя
& - используется для получения адреса переменной и передачи по ссылке
new - используется для создания безымянных обьектов (не имеют имени, но имеют адрес)


------------------------------------------------------------

слайс это структура из трёх полей — указателя на массив, длины и вместимости (capacity):

type slice struct {
        array unsafe.Pointer
        len   int
        cap   int
}

Когда вы создаёте новый слайс, рантайм "под капотом" создаст новую переменную этого типа, с нулевым указателем (nil) и длиной и ёмкостью равными нулю. Это нулевое значение для слайса. 


foo = make([]int, 5)

Эта команда создаст сначала массив из 5 элементов (выделит память и заполнит их нулями), и установит значения len и cap в 5. Cap означает ёмкость и помогает зарезервировать место в памяти на будущее, чтобы избежать лишних операций выделения памяти при росте слайса.

!если не указать capacity - оно присвоится по длине слайса

foo = make([]int, 5)
foo[3] = 42
foo[4] = 100

bar  := foo[1:4]

при такой форме определения слайса, 0 элемент слайса начнется с 1 массива и будет длиной до 4, однако в емкость слайса
запишется полная длина массива

bar[1] = 99

Здесь слайс управляет видимой частью массива.


Модифицируя слайс bar, мы, на самом деле, изменяем массив, но это тот же самый массив, на который указывает и слайс foo.

a := make([]int, 32)
a = append(a, 1)

make новый слайс из 32 целых чисел и добавляет к нему ещё один, 33-й элемент.

Функция append() проверяет, достаточно ли у слайса места, чтобы добавить туда ещё элемент, и если нет, то выделяет больше памяти. Выделение памяти это всегда дорогая операция, поэтому append() пытается оптимизировать это, и запрашивает в данном случае памяти не для одной переменной, а для ещё 32х — в два раза больше, чем начальный размер. Выделение памяти пачкой один раз дешевле, чем много раз по кусочкам.

Неочевидная штука тут в том, что по различным причинам, выделение памяти обычно означает выделение её по другому адресу и перемещение данных из старого места в новое. Это означает, что адрес массива, на который ссылается слайс также изменится!

append() увеличивает слайс удвоением только до 1024 байт, а затем начинает использовать другой подход — так называемые "классы размеров памяти", которые гарантируют, что будет выделяться не более ~12.5%. Выделять 64 байта для массива на 32 байта это нормально, но если слайс размером 4ГБ, то выделять ещё 4ГБ даже если мы хотим добавить лишь один элемент — это чересчур дорого.

Когда append пытается добавить новые данные в слайс, он смотрит на емкость слайса, (обычно она равна длине исходного массива) если она позволяет добавить новые данные - они добавляются в слайс и меняются оригинальные данные в массиве на который ссылается слайс, если емкость не позволяет - создается новый массив, создается ссылка на него, и в нем изменяются данные. Старый массив остается неизменным.
------------------------------------------------------------

Многопоточность

Go имеет богатую функциональность для работы с многопоточностью, в частности, такие инструменты как горутины и каналы.

Горутина — это функция, которая может работать параллельно с другими функциями. Для создания горутины используется ключевое слово go, за которым следует вызов функции.

Функция main, сама по себе, является горутиной.
Вторая горутина создаётся, когда мы вызываем go f(0).

Каналы обеспечивают возможность общения нескольких горутин друг с другом, чтобы синхронизировать их выполнение.
Конструкция c <- "ping" означает отправку "ping", а msg := <- c — его получение и сохранение в переменную msg.
Когда pinger пытается послать сообщение в канал, он ожидает, пока printer будет готов получить сообщение. Такое поведение называется блокирующим. 

package main

import (
    "fmt"
    "time"
)

func pinger(c chan string) {
    for i := 0; ; i++ {
        c <- "ping"
    }
}
func printer(c chan string) {
    for {
        msg := <- c
        fmt.Println(msg)
        time.Sleep(time.Second * 1)
    }
}
func main() {
    var c chan string = make(chan string)

    go pinger(c)
    go printer(c)

    var input string
    fmt.Scanln(&input)
}

Мы можем задать направление передачи сообщений в канале, сделав его только отправляющим или принимающим. 
Например:

Принимающий:
func pinger(c chan<- string)

Отправляющий:
func printer(c <-chan string)

В языке Go есть специальный оператор select который работает как switch, но для каналов.
Оператор select выбирает первый готовый канал, и получает сообщение из него, или же передает сообщение через него. 
Когда готовы несколько каналов, получение сообщения происходит из случайно выбранного готового канала. Если же ни один из каналов не готов, оператор блокирует ход программы до тех пор, пока какой-либо из каналов будет готов к отправке или получению.

------------------------------------------------------------

func Intn(n int) int

Intn возвращает в виде int неотрицательное псевдослучайное число в полуоткрытом интервале [0,n) (больше 0, но меньше n)

------------------------------------------------------------

В Go только один оператор равенства, через который нельзя сравнивать текст и число. Тем не менее, можно конвертировать число в текст и наоборот.

------------------------------------------------------------

Go использует логику короткого замыкания.
Если первое условие истинно, тогда нет нужды проверять условие, что следует за оператором ||, поэтому оно будет игнорироваться.

------------------------------------------------------------

Оператор fallthrough используется в предложении case switch. Он должен использоваться в конце предложения case.
Он используется для выполнения следующего предложения case без проверки выражения.

------------------------------------------------------------

range

цикл range предоставляет как index (или ключ в map), так и текущее value.

------------------------------------------------------------

:= - обьявление и присваивание
= только присваивание

Вы не можете использовать := вне funcs. Это потому, что вне функции оператор должен начинаться с ключевого слова.
Всеоператоры вне функции должны начинаться с ключевого слова

:= можно использовать для многопеременных объявлений и назначений

foo, bar := 42, 314

------------------------------------------------------------

Функция main() должна появляться в коде только один раз, находиться в пакете main(), и не получать и не возвращать никаких аргументов.

Полная программа создается путем транзитивного связывания одного неимпортированного пакета, 
называемого основным пакетом , со всеми пакетами, которые он импортирует. 
Основной пакет должен иметь имя пакета main и объявлять функцию main, 
которая не принимает аргументов и не возвращает значения.

Выполнение программы начинается с инициализации программы и последующего вызова функции mainв package main. 
Когда вызов этой функции возвращается, программа завершается. Она не ждет main завершения других горутин.

------------------------------------------------------------
для преобразования типа можно использовать имя типа в качестве функции.

float64(x)

------------------------------------------------------------
массив - структура данных с фиксированной длинной

x := [5]float64{98, 93, 77, 82, 83}

срез - структура данных с нефиксированной длинной

Срезы (slice) представляют последовательность элементов одного типа переменной длины. 
В отличие от массивов длина в срезах не фиксирована и динамически может меняться, 
то есть можно добавлять новые элементы или удалять уже существующие.

Срез создается встроенной функцией make:
x := make([]float64, 5)

append создает новый срез из уже существующего (первый аргумент) и добавляет к нему все следующие аргументы.

map (также известна как ассоциативный массив или словарь) — это неупорядоченная коллекция пар вида ключ-значение. 

очень частый способ использования карт — в качестве словаря или таблицы. 

make([]int, 3, 9)
здесь длина среза 3, длина массива на который указывает срез 9

------------------------------------------------------------

Go использует неявный оператор break для каждого случая.

------------------------------------------------------------

Сигнатура функции - совокупность аргументов и возвращаемых значений

Тело фукнции - код заключенный в фигурных скобках

panic - вызывает ошибку выполнения

функции не имеют доступа к области видимости родительской функции

функции выстраиваются в «стек вызовов».

При создании локальная функция также получает доступ к локальным переменным

Функцию, использующую переменные, определенные вне этой функции, называют замыканием.

defer позволяет отложить вызов указанной функции до тех пор, пока не завершится текущая. 
Грубо говоря defer перемещает вызов функции в конец текущей
отложенные функции вызываются, даже если во время выполнения происходит ошибка.
Например:
f, _ := os.Open(filename)
defer f.Close()

------------------------------------------------------------

Panic - генерация ошибки 
recover - останавливает панику и возвращает значение, которое было передано функции panic.
Recover следует использова в связке с defer

------------------------------------------------------------

Горутины — это функции или методы, выполняемые конкурентно с другими горутинами в одном и том же адресном пространстве. 
Они легковеснее традиционных потоков, занимают меньше памяти и позволяют эффективно использовать ядра процессора.

sync.WaitGroup - простой способ дождаться выполнения всех горутин

При коммуникации горутин нет необходимости использовать WaitGroup так как мы ожидаем выполнения всех горутин при помощи механизма чтения из канала.

------------------------------------------------------------

Указатели указывают на участок в памяти, где хранится значение.
(передача по ссылке из php)

оператор &, который используется для получения адреса переменной. 

new принимает аргументом тип, выделяет для него память и возвращает указатель на эту память.

------------------------------------------------------------

Краткое объявление недоступно для переменных, объявленных в области видимости пакета
затычка
------------------------------------------------------------

Тип - описание будущей структуры
(аналог класса из пхп)

Структура — это тип, содержащий именованные поля. 
(посути аналог обьекта пхп)
По умолчанию аргументы в Go всегда копируются. 

Структура — это пользовательский тип, предназначенный для объединения нескольких полей
(с разными или одинаковыми типами) в единую сущность. 
Структура позволяет описывать сложные объекты и связывать с ними методы.

Функция с получателем - аналог метода обьекта из пхп. Подвязывает метод к структуре, и в дальнейшем мы
можем обратиться к этому методу из структуры.

Встраиваемые типы - один тип вложенный в другой (структура в структуре)

Интерфейс - описывает какие методы реализуются в структуре
Множество методов - это список методов, которые будут использоваться для «реализации» интерфейса.

Интерфейсы представляют абстракцию поведения других типов. Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации. То есть интерфейсы определяют некоторый функционал, но не реализуют его.

В Go интерфейс реализуется неявно. Нам не надо специально указывать, что структуры применяют определенный интерфейс, как в некоторых других языках программирования:

package main
 
import "fmt"
 
type Car struct{ }
type Aircraft struct{}
 
 
func (c Car) move(){
    fmt.Println("Автомобиль едет")
}
func (a Aircraft) move(){
    fmt.Println("Самолет летит")
}
 
func driveCar(c Car){
    c.move()
}
func driveAircraft(a Aircraft){
    a.move()
}
 
func main() {
     
    var tesla Car = Car{}
    var boing Aircraft = Aircraft{}
    driveCar(tesla)
    driveAircraft(boing)
}
}

------------------------------------------------------------
При делении стоит быть внимательным, так как если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной типа float32/float64:

------------------------------------------------------------
rune — это алиас к int32. руна представляет собой код символа стандарта Юникод

Если использовать конструкцию for range, строка автоматически будет преобразована в []rune

массив в Go - структура данных фиксированного размера, хранящая элементы одного типа

------------------------------------------------------------ 
spread оператор в go:

1. Для подсчета компилятором Go количества элементов композитного литера для массива;
2. Заставить последний параметр вариативной функции зафиксировать ноль или большее число аргументов в качестве среза;
3. Расширить элементы среза в аргументы, передаваемые функции.