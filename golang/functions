Длина числа:
Функция utf8.RuneCountInString подсчитывает юникодные символы без записи в память. 
Поэтому, если вам нужно только число символов, эта функция будет быстрее, чем len([]rune(txt)).

package main

import (
    "fmt"
    "unicode/utf8"
)

func main() {
	textNumber := strconv.Itoa(123)
    fmt.Println(utf8.RuneCountInString(textNumber))
}

------------------------------------------------------------

Перевод числа в слайс:

package main

import (
	"fmt"
)

func main() {
	salary := 1234
	intSlice := IntToSlice(salary, make([]int, 0))
	fmt.Println(intSlice)
}

func IntToSlice(n int, sequence []int) []int {
	for n > 0 {
		i := n % 10
		sequence = append([]int{i}, sequence...)
		n = n / 10
	}
	return sequence
}

------------------------------------------------------------

//проблема reverse number!
//скорее всего самый удобный способ - привести число к строке и через итерирование строки заполнять slice

package main

import (
	"fmt"
	"strconv"
	"unicode/utf8"
)

func main() {
	salary := 990778876

	salarySlice, minIndex := getSliceSalary(salary)

	fmt.Println(salarySlice)
	fmt.Println(minIndex)
}

func getSliceSalary(salary int) ([]int, int) {
	textNumber := strconv.Itoa(salary)
	sliceSalary := make([]int, 0, utf8.RuneCountInString(textNumber))
	minNumber := 9
	minIndex := 0
	currentIndex := 0

	for _, currentTextNumber := range textNumber {
		currentNumber, _ := strconv.Atoi(string(currentTextNumber))
		sliceSalary = append(sliceSalary, currentNumber)
		if currentNumber < minNumber {
			minNumber = currentNumber
			minIndex = currentIndex
		}
		currentIndex++
	}

	sliceSalary = append(sliceSalary[:minIndex], sliceSalary[+minIndex:]...)
	
	return sliceSalary, minIndex
}


